---
description: Добавление новых полей в FormFields
alwaysApply: false
---

# Правила добавления новых полей в FormFields

## Назначение модуля FormFields

Модуль `/df-landing/src/components/FormFields/` содержит **все переиспользуемые поля форм** в виде **презентационных компонентов**. Каждое поле изолировано в отдельной папке для удобства поддержки и тестирования.

## Структура модуля

```
src/components/FormFields/
├── types.ts                    # Базовые интерфейсы пропсов
├── FormFields.module.scss      # Общие стили
├── index.ts                    # Реэкспорт Field и types
├── Field.ts                    # Объединение всех полей
│
├── Name/
│   ├── Name.tsx               # Компонент поля
│   └── index.ts               # Реэкспорт
├── FirstName/
│   ├── FirstName.tsx
│   └── index.ts
... (55 полей)
└── PriceMode/
    ├── PriceMode.tsx
    └── index.ts
```

**Принципы:**

- Каждое поле - отдельная папка с компонентом
- Все поля реализованы как чистые презентационные компоненты без бизнес-логики
- Базовые типы пропсов вынесены в `types.ts`
- Все поля объединены в объект `Field` в файле `Field.ts`

## Обязательные входные данные

Перед добавлением нового поля необходимо **обязательно** иметь следующую информацию:

1. **Название поля** - CamelCase название (например: `EmploymentForm`, `HiredEmploymentType`, `LoanPurpose`)
2. **Тип данных модели** - класс модели данных из `@/models` (например: `EmploymentFormData`, `HiredEmploymentTypeData`, `LoanData`)
    - ⚠️ **Только для полей с выбором** (Autocomplete, CheckList) - для простых Input'ов модель не нужна
3. **Label по умолчанию** - текст метки поля (например: "Форма трудоустройства", "Форма трудовых отношений")
4. **Тип компонента** - простой Input, Autocomplete с автокомплитом, InputWithSlider, FileUploader и т.д.

⚠️ **ВАЖНО:** Перед созданием нового поля **обязательно проверьте**, не существует ли уже такое поле!

## Базовые типы пропсов

Все базовые типы пропсов определены в файле `types.ts`:

### BaseFieldProps

Используется для **простых полей** (Input, InputWithSlider и т.д.):

```typescript
interface BaseFieldProps<T extends unknown = string> {
    value: T | null;
    onChange: (value: T | null) => void;
    error?: boolean;
    errorText?: string;
    label?: string;
    className?: string;
    disabled?: boolean;
    readOnly?: boolean;
}
```

**Импорт:**

```typescript
import {BaseFieldProps} from '../types';
```

**Дженерик `T`:**

- По умолчанию `string` для текстовых полей
- Может быть `number` для числовых полей
- Может быть любым типом для специфичных полей (например, `string[]` для множественного выбора)

### AutocompleteFieldProps

Используется для **полей с выбором** (Autocomplete):

```typescript
interface AutocompleteFieldProps<
    T extends {[key: string]: any},
    K extends unknown = string
> extends BaseFieldProps<K> {
    options: T[];
    loading?: boolean;
}
```

**Импорт:**

```typescript
import {AutocompleteFieldProps} from '../types';
```

**Дженерики:**

- `T` - тип модели данных (что содержится в `options`), например `EmploymentFormData`, `RegionData`
- `K` - тип значения поля (что в `value` и `onChange`), по умолчанию `string`
    - Для большинства полей используется `string` (ID из справочника)
    - Может быть кастомным типом, например `EmploymentFormTypes` для enum-значений
    - Может быть `string[]` для множественного выбора

**Примеры использования:**

```typescript
// Простой случай - значение string (ID)
AutocompleteFieldProps<LoanData>;
// Эквивалентно: AutocompleteFieldProps<LoanData, string>

// С кастомным типом значения (enum)
AutocompleteFieldProps<EmploymentFormData, EmploymentFormTypes>;

// Для множественного выбора
AutocompleteFieldProps<RegionData, string[]>;
```

### FileUploadFieldProps

Используется для **полей загрузки файлов** (FileUploader):

```typescript
interface FileUploadFieldProps extends Omit<BaseFieldProps, 'onChange' | 'value'> {
    value: File[];
    onChange: (value: File[]) => void;
    multiple?: boolean;
    maxSizeMB?: number;
    acceptTypes?: AcceptTypes[];
    dropZoneText?: string;
    loading?: boolean;
    onDelete?: (file: File) => void;
}
```

**Импорт:**

```typescript
import {FileUploadFieldProps} from '../types';
```

**Ключевые отличия от BaseFieldProps:**

- `value: File[]` - всегда массив файлов (не `File | null`)
- `onChange: (value: File[]) => void` - принимает массив файлов (не `File | null`)
- Дополнительные пропсы для настройки загрузчика

**Параметры:**

- `multiple` - разрешить загрузку нескольких файлов
- `maxSizeMB` - максимальный размер файла в мегабайтах
- `acceptTypes` - допустимые типы файлов (например: `['.pdf', '.png', '.jpg', '.jpeg']`)
- `dropZoneText` - текст в зоне перетаскивания
- `loading` - состояние загрузки
- `onDelete` - колбэк удаления файла

**Тип AcceptTypes:**

Импортируется из `@/ui` и определяет допустимые типы файлов.

### CheckListFieldProps

Используется для **полей множественного выбора с чекбоксами** (CheckList):

```typescript
interface CheckListFieldProps<T extends unknown = string> {
    value: T[] | null;
    onChange: (value: T[] | null) => void;
    title?: string;
    error?: boolean;
    errorText?: string;
    className?: string;
    disabled?: boolean;
}
```

**Импорт:**

```typescript
import {CheckListFieldProps} from '../types';
```

**Дженерик `T`:**

- По умолчанию `string` для простых списков
- Может быть union-типом для типизированных списков (например, `WorkTypesUnion`, `RealtyTypeUnion`)

**Ключевые отличия от BaseFieldProps:**

- `value: T[] | null` - всегда массив (не единичное значение)
- `onChange: (value: T[] | null) => void` - принимает массив
- `title` вместо `label` - заголовок группы чекбоксов
- Нет `readOnly` - для чекбоксов используется только `disabled`

**Примеры использования:**

```typescript
// Простой случай - значение string[]
CheckListFieldProps;
// Эквивалентно: CheckListFieldProps<string>

// С типизированным union-типом
CheckListFieldProps<WorkTypesUnion> & {
    workTypes: WorkTypesUnion[];
};

// С дополнительными опциями
CheckListFieldProps & {
    options: {id: string; title: string}[];
    maxSelected?: number;
};
```

### Дополнительные типы

В `types.ts` также определены вспомогательные типы:

```typescript
// Для поля PersonalDataAgreement
export interface PersonalDataAgreementProps {
    checked: boolean;
    onCheckedChange: (value: boolean) => void;
    error?: boolean;
    color?: CheckboxColor;
    agreementTextClassName?: string;
}

// Union-типы для специфичных полей
export type WorkTypesUnion =
    | keyof typeof RentWorkTypes
    | keyof typeof SaleWorkTypes
    | keyof typeof MortgageCreditWorkTypes;

export type RealtyTypeUnion = keyof typeof RealtyTypes;
```

### Расширение базовых типов

**По умолчанию используйте один из базовых типов.** Если нужно что-то уникальное для конкретного поля - расширяйте тип отдельно:

```typescript
// Пример расширения для поля Phone с дополнительными пропсами
export const Phone = ({
    value,
    onChange,
    error,
    errorText,
    label = 'Телефон',
    className,
    endAdornment, // ← Дополнительный проп
    readOnly,
    autoComplete = 'tel',
    helperText // ← Дополнительный проп
}: BaseFieldProps & {
    endAdornment?: React.ReactNode;
    autoComplete?: string;
    helperText?: React.ReactNode;
}) => {
    // ...
};
```

## Типы полей

### 1. Простое текстовое поле (Input)

Используется для ввода текста, телефона, email и других простых значений.

**Пример: Name, Phone, Email, WorkPlace**

**Тип пропсов:** `BaseFieldProps` (модель данных не требуется)

**Структура файла `FieldName/FieldName.tsx`:**

```typescript
'use client';

import {Input} from '@/ui';
import {BaseFieldProps} from '../types';

export const FieldName = ({
    value,
    onChange,
    error,
    errorText,
    label = 'Метка поля',
    className,
    disabled,
    readOnly
}: BaseFieldProps) => {
    return (
        <Input
            id="fieldId"
            autoComplete="autocomplete-value"
            label={label}
            value={value ?? ''}
            onChange={onChange}
            error={error}
            errorText={errorText}
            fullWidth
            className={className}
            disabled={disabled}
            readOnly={readOnly}
        />
    );
};
```

**Ключевые параметры:**

- `BaseFieldProps` - базовый тип, используется по умолчанию для простых Input'ов
- `id` - уникальный идентификатор поля (camelCase)
- `autoComplete` - HTML атрибут автозаполнения (опционально)
- `mask` - маска для форматирования ввода (например: "phone", "year", "custom")
- `inputMode` - тип клавиатуры на мобильных устройствах

**Расширение для уникальных полей:**

```typescript
// Если нужны дополнительные пропсы - расширяем BaseFieldProps
export const Phone = ({
    value,
    onChange,
    // ... стандартные пропсы из BaseFieldProps
    endAdornment, // ← Дополнительный проп
    autoComplete = 'tel',
    helperText
}: BaseFieldProps & {
    endAdornment?: React.ReactNode;
    autoComplete?: string;
    helperText?: React.ReactNode;
}) => {
    // ...
};
```

### 2. Поле с автокомплитом (Autocomplete)

Используется для выбора значения из справочника с возможностью поиска.

**Пример: EmploymentForm, HiredEmploymentType, LoanPurpose, Region**

**Тип пропсов:** `AutocompleteFieldProps<T>` (требуется модель данных)

**Структура файла `FieldName/FieldName.tsx`:**

```typescript
'use client';

import {Autocomplete} from '@/ui';
import {DataType} from '@/models';
import {AutocompleteFieldProps} from '../types';

export const FieldName = ({
    value,
    onChange,
    error,
    errorText,
    options,
    loading,
    label = 'Метка поля',
    className,
    disabled
}: AutocompleteFieldProps<DataType>) => {
    return (
        <Autocomplete
            id="fieldId"
            label={label}
            className={className}
            value={options.find((option) => option.id === value)}
            onChange={(v) => {
                if (!v || typeof v === 'string') {
                    onChange(null);
                } else {
                    onChange(v.id);
                }
            }}
            onBlur={(e, {filteredOptions}) => {
                if (filteredOptions.length === 1) onChange(filteredOptions[0].id ?? null);
            }}
            error={error}
            errorText={errorText}
            options={options}
            getOptionLabel={(option) => option.title}
            getOptionKey={(option) => option.id}
            clearable
            loading={loading}
            noOptionsText="Значение не найдено"
            disabled={disabled}
        />
    );
};
```

**Ключевые параметры:**

- `AutocompleteFieldProps<T, K>` - типизация с двумя дженериками:
    - `T` - тип модели данных из `@/models` (например, `EmploymentFormData`, `RegionData`)
    - `K` - тип значения поля (опционально, по умолчанию `string`)
- `options: T[]` - массив данных для выбора (автоматически добавляется из `AutocompleteFieldProps`)
- `loading?: boolean` - состояние загрузки (автоматически добавляется из `AutocompleteFieldProps`)
- `getOptionLabel` - функция получения отображаемого текста (обычно `option.title` или `option.name`)
- `getOptionKey` - функция получения уникального ключа (обычно `option.id` или `option.fiasId`)
- `noOptionsText` - текст при отсутствии результатов
- `clearable` - возможность очистить поле
- `onBlur` - автовыбор, если найдена только одна опция

**Когда указывать второй дженерик `K`:**

- Не указывайте, если значение - это `string` (ID элемента) - используется по умолчанию
- Укажите, если значение - это enum или кастомный тип: `AutocompleteFieldProps<EmploymentFormData, EmploymentFormTypes>`
- Укажите, если значение - это массив: `AutocompleteFieldProps<RegionData, string[]>` (для полей с множественным выбором)

### 3. Поле с ползунком (InputWithSlider)

Используется для ввода числовых значений с визуальным ползунком.

**Пример: ObjectPrice, DownPayment, LoanTerm, MonthlyIncome**

**Тип пропсов:** `BaseFieldProps<number>` (модель данных не требуется) + расширение для `onBlur`

**Структура файла `FieldName/FieldName.tsx`:**

```typescript
'use client';

import {isNumber} from 'lodash';
import {InputWithSlider} from '@/components/shared';
import {BaseFieldProps} from '../types';

export const FieldName = ({
    value,
    onChange,
    onBlur,
    label = 'Метка поля',
    className,
    error,
    errorText
}: BaseFieldProps<number> & {
    onBlur?: () => void;
}) => {
    return (
        <InputWithSlider
            id="fieldId"
            label={label}
            className={className}
            value={value}
            onValueChange={onChange}
            onBlur={onBlur}
            error={error}
            errorText={errorText}
            min={MIN_VALUE}
            max={MAX_VALUE}
            step={STEP_VALUE}
            sliderRangeLabels={['Мин', 'Средн', 'Макс']}
            mask={isNumber(value) && String(value).length > 3 ? 'custom' : undefined}
            maskPattern="numeric"
            maskOptions={{
                groupSeparator: ' ',
                digits: 0,
                placeholder: '',
                rightAlign: false,
                max: '9999999',
                allowMinus: false
            }}
        />
    );
};
```

**Ключевые параметры:**

- `BaseFieldProps<number>` - базовый тип с дженериком для числового значения
- `& { onBlur?: () => void }` - расширение базового типа для добавления `onBlur` колбэка
- `min`, `max`, `step` - ограничения и шаг ползунка
- `sliderRangeLabels` - подписи под ползунком (минимум, середина, максимум)
- `maskOptions` - настройки маски для форматирования числа

### 4. Множественный выбор с чекбоксами (CheckList)

Используется для выбора нескольких значений из списка.

**Пример: WorkTypes, RealtyType, ModuleTypes**

**Тип пропсов:** `CheckListFieldProps<T>` с расширением для специфичных опций

**Структура файла `FieldName/FieldName.tsx`:**

```typescript
'use client';

import cn from 'classnames';
import {CheckList} from '@/components/shared';
import {CheckListFieldProps, WorkTypesUnion} from '../types';
import s from '../FormFields.module.scss';

export const FieldName = ({
    value,
    onChange,
    workTypes,
    title,
    error,
    errorText,
    className,
    disabled
}: CheckListFieldProps<WorkTypesUnion> & {
    workTypes: WorkTypesUnion[];
}) => {
    value = value ?? [];

    const handleChange = (key: WorkTypesUnion, checked: boolean) => {
        onChange(checked ? [...value, key] : value.filter((k) => k !== key));
    };

    return (
        <CheckList.List className={className}>
            {title && <h5 className={cn(s.checkListTitle, error && s.error)}>{title}</h5>}
            {error && errorText && <p className={s.errorText}>{errorText}</p>}
            {workTypes.map((key) => {
                const label = LabelsMap[key] ?? '';
                return (
                    <CheckList.Item
                        key={key}
                        label={label}
                        checked={value.includes(key)}
                        onChange={(checked) => handleChange(key, checked)}
                        disabled={disabled}
                    />
                );
            })}
        </CheckList.List>
    );
};
```

### 5. Множественный выбор с чипами (Chips)

Используется для выбора нескольких значений из автокомплита с отображением в виде чипов.

**Пример: OperatingRegions**

**Тип пропсов:** `AutocompleteFieldProps<T, string[]>` (требуется модель данных)

**Структура файла `FieldName/FieldName.tsx`:**

```typescript
'use client';

import {useMemo} from 'react';
import cn from 'classnames';
import {Autocomplete, Chip} from '@/ui';
import {RegionData} from '@/models';
import {AutocompleteFieldProps} from '../types';
import s from '../FormFields.module.scss';

export const FieldName = ({
    value,
    error,
    errorText,
    label = 'Метка поля',
    loading,
    options,
    onChange,
    className,
    disabled
}: AutocompleteFieldProps<RegionData, string[]>) => {
    const filteredOptions = useMemo(() => {
        return options.filter((item) => !value?.includes(item.id));
    }, [options, value]);

    const handleSelect = (v: RegionData) => {
        onChange([...(value ?? []), v.id]);
    };

    const handleDelete = (id: string) => {
        onChange(value?.filter((r) => r !== id) ?? []);
    };

    return (
        <div className={cn(s.container, className)}>
            <Autocomplete
                id="fieldId"
                label={label}
                options={filteredOptions}
                onChange={(v) => {
                    if (v && typeof v !== 'string') handleSelect(v);
                }}
                loading={loading}
                getOptionKey={(option) => option.id}
                getOptionLabel={(option) => option.title}
                clearable
                noOptionsText="Значение не найдено"
                error={error}
                errorText={errorText}
                disabled={disabled}
            />

            {value && value.length > 0 && (
                <div className={s.chips}>
                    {value.map((id) => (
                        <Chip
                            key={id}
                            label={options.find((r) => r.id === id)?.title ?? ''}
                            onDelete={() => handleDelete(id)}
                        />
                    ))}
                </div>
            )}
        </div>
    );
};
```

### 6. Поле загрузки файлов (FileUploader)

Используется для загрузки одного или нескольких файлов с поддержкой drag-and-drop.

**Пример: CreditFiles**

**Тип пропсов:** `FileUploadFieldProps` (модель данных не требуется)

**Структура файла `FieldName/FieldName.tsx`:**

```typescript
'use client';

import {FileUploader} from '@/ui';
import {FileUploadFieldProps} from '../types';

export const FieldName = ({
    value,
    onChange,
    error,
    errorText,
    onDelete,
    acceptTypes = ['.pdf', '.png', '.jpg', '.jpeg'],
    maxSizeMB = 20,
    dropZoneText = 'Перетащите файлы в эту область'
}: FileUploadFieldProps) => {
    return (
        <FileUploader.Root
            id="fieldId"
            value={value}
            onChange={onChange}
            multiple
            error={error}
            errorText={errorText}
            maxSizeMB={maxSizeMB}
            acceptTypes={acceptTypes}
            dropZoneText={dropZoneText}
        >
            <FileUploader.List>
                {value.map((file) => (
                    <FileUploader.Item
                        key={file.name}
                        fileName={file.name}
                        onDelete={() => onDelete?.(file)}
                    />
                ))}
            </FileUploader.List>
        </FileUploader.Root>
    );
};
```

**Ключевые параметры:**

- `FileUploadFieldProps` - специальный тип для полей загрузки файлов
- `value: File[]` - массив загруженных файлов
- `onChange: (value: File[]) => void` - колбэк изменения списка файлов
- `onDelete?: (file: File) => void` - колбэк удаления конкретного файла
- `acceptTypes` - массив допустимых расширений (например: `['.pdf', '.png', '.jpg']`)
- `maxSizeMB` - максимальный размер файла в мегабайтах
- `dropZoneText` - текст-подсказка в зоне перетаскивания
- `multiple` - флаг множественной загрузки (передается в `FileUploader.Root`)

**Структура компонента FileUploader:**

- `FileUploader.Root` - корневой контейнер с зоной drop
- `FileUploader.List` - контейнер для списка файлов
- `FileUploader.Item` - элемент списка с превью и кнопкой удаления

## Пошаговая инструкция добавления нового поля

### Шаг 1: Проверка существования поля

```bash
# Проверьте, не существует ли уже такая папка с полем
ls -la src/components/FormFields/ | grep FieldName

# Или проверьте в Field.ts
grep -n "FieldName" src/components/FormFields/Field.ts
```

### Шаг 2: Проверка существования модели данных

Убедитесь, что модель данных уже создана в `/df-landing/src/models/DadataModels.ts` (или другом файле моделей) и экспортирована в `/df-landing/src/models/index.ts`.

### Шаг 3: Создание папки и файлов поля

Создайте папку для нового поля:

```bash
mkdir src/components/FormFields/FieldName
```

### Шаг 4: Создание компонента поля

Создайте файл `FieldName/FieldName.tsx` с компонентом:

**Пример 1: Простой Autocomplete со string значением**

```typescript
'use client';

import {Autocomplete} from '@/ui';
import {HiredEmploymentTypeData} from '@/models';
import {AutocompleteFieldProps} from '../types';

export const HiredEmploymentType = ({
    value,
    onChange,
    error,
    errorText,
    options,
    loading,
    label = 'Форма трудовых отношений',
    className,
    disabled
}: AutocompleteFieldProps<HiredEmploymentTypeData>) => {
    return (
        <Autocomplete
            id="hiredEmploymentType"
            label={label}
            className={className}
            value={options.find((option) => option.id === value)}
            onChange={(v) => {
                if (!v || typeof v === 'string') {
                    onChange(null);
                } else {
                    onChange(v.id);
                }
            }}
            onBlur={(e, {filteredOptions}) => {
                if (filteredOptions.length === 1) onChange(filteredOptions[0].id ?? null);
            }}
            error={error}
            errorText={errorText}
            options={options}
            getOptionLabel={(option) => option.title}
            getOptionKey={(option) => option.id}
            clearable
            loading={loading}
            disabled={disabled}
        />
    );
};
```

**Пример 2: Autocomplete с кастомным типом значения (enum)**

```typescript
'use client';

import {EmploymentFormTypes} from '@/const';
import {Autocomplete} from '@/ui';
import {EmploymentFormData} from '@/models';
import {AutocompleteFieldProps} from '../types';

export const EmploymentForm = ({
    value,
    onChange,
    error,
    errorText,
    options,
    loading,
    label = 'Форма трудоустройства',
    className,
    disabled
}: AutocompleteFieldProps<EmploymentFormData, EmploymentFormTypes>) => {
    return (
        <Autocomplete
            id="employmentForm"
            label={label}
            className={className}
            value={options.find((option) => option.id === value)}
            onChange={(v) => {
                if (!v || typeof v === 'string') {
                    onChange(null);
                } else {
                    onChange(v.id);
                }
            }}
            onBlur={(e, {filteredOptions}) => {
                if (filteredOptions.length === 1) onChange(filteredOptions[0].id ?? null);
            }}
            error={error}
            errorText={errorText}
            options={options}
            getOptionLabel={(option) => option.title}
            getOptionKey={(option) => option.id}
            clearable
            loading={loading}
            disabled={disabled}
        />
    );
};
```

**Обратите внимание:**

- Если значение - это просто `string` (ID), используйте `AutocompleteFieldProps<ModelData>` без второго дженерика
- Если значение - это enum или кастомный тип, добавьте второй дженерик: `AutocompleteFieldProps<ModelData, CustomType>`
- Импорт типов всегда из `'../types'`
- Импорт общих стилей из `'../FormFields.module.scss'` (если нужны)

### Шаг 5: Создание файла реэкспорта

Создайте файл `FieldName/index.ts`:

```typescript
export {FieldName} from './FieldName';
```

### Шаг 6: Добавление в Field.ts

Добавьте импорт и регистрацию в файл `Field.ts`:

```typescript
// В начале файла - добавьте импорт
import {FieldName} from './FieldName';

// В объекте Field - добавьте поле
export const Field = {
    Name,
    FirstName,
    // ... другие поля
    FieldName // ← Новое поле
    // ... остальные поля
};
```

### Шаг 7: Проверка линтера

После добавления поля проверьте отсутствие ошибок линтера:

```bash
npm run lint
```

## Использование полей

После добавления поля его можно использовать в любых формах проекта:

```tsx
import {Field} from '@/components/FormFields';

// В компоненте формы:
<Field.EmploymentForm
    value={employmentFormId}
    onChange={setEmploymentFormId}
    options={employmentForms}
    loading={loading}
    error={!!errors.employmentForm}
    errorText={errors.employmentForm}
/>;

// Для поля загрузки файлов:
<Field.CreditFiles
    value={files}
    onChange={setFiles}
    onDelete={handleDeleteFile}
    acceptTypes={['.pdf', '.png', '.jpg']}
    maxSizeMB={10}
    dropZoneText="Загрузите документы"
    error={!!errors.files}
    errorText={errors.files}
/>;
```

## Принципы именования

### Имя компонента

- **Задается в промпте пользователя** - например: "Создай поле Phone", "Добавь поле EmploymentForm"
- Формат: **CamelCase**
- Для полей с моделью данных: совпадает с названием модели без суффикса "Data"
    - Модель `EmploymentFormData` → компонент `EmploymentForm`
    - Модель `HiredEmploymentTypeData` → компонент `HiredEmploymentType`
- Для простых полей: логическое название на английском
    - `Phone`, `Email`, `WorkPlace`
- Примеры: `EmploymentForm`, `HiredEmploymentType`, `LoanPurpose`, `Phone`, `Email`

### Имя папки

- Совпадает с именем компонента (CamelCase)
- Примеры: `EmploymentForm/`, `HiredEmploymentType/`, `Phone/`

### ID поля

- **camelCase**, совпадает с именем компонента
- Примеры: `employmentForm`, `hiredEmploymentType`, `loanPurpose`

### Label

- Понятное русское название
- Примеры: "Форма трудоустройства", "Форма трудовых отношений", "Цель кредита"

### noOptionsText

- **Только для полей на базе Autocomplete** - текст, отображаемый при отсутствии результатов поиска
- Формат: "{Label} не найден/не найдена/не найдено"
- Примеры: "Форма трудоустройства не найдена", "Регион не найден"
- Для других типов полей (Input, InputWithSlider, CheckList) этот параметр не используется

## Контрольный список

Перед завершением работы убедитесь, что:

- [ ] Проверено отсутствие дублирующего поля (папки)
- [ ] Модель данных существует и экспортирована из `@/models` (только для Autocomplete-полей)
- [ ] Создана папка `FieldName/` в `src/components/FormFields/`
- [ ] Создан файл `FieldName/FieldName.tsx` с компонентом
- [ ] Создан файл `FieldName/index.ts` с реэкспортом
- [ ] Компонент создан как презентационный (без бизнес-логики)
- [ ] Компонент использует правильные типы из `../types`:
    - `BaseFieldProps` - для простых текстовых Input (по умолчанию `string`)
    - `BaseFieldProps<number>` - для числовых полей
    - `BaseFieldProps<CustomType>` - для полей с кастомным типом значения
    - `AutocompleteFieldProps<T>` - для Autocomplete со `string` значением (ID)
    - `AutocompleteFieldProps<T, K>` - для Autocomplete с кастомным типом значения `K`
    - `FileUploadFieldProps` - для полей загрузки файлов (FileUploader)
    - `CheckListFieldProps<T>` - для множественного выбора с чекбоксами
    - Кастомные типы с расширением базовых - только при необходимости уникальных пропсов
- [ ] ID поля уникален и соответствует имени
- [ ] Label по умолчанию понятен и на русском языке
- [ ] Поле добавлено в импорт и объект `Field` в файле `Field.ts`
- [ ] Нет ошибок линтера
- [ ] Поле следует паттернам аналогичных существующих полей

## Примеры по типам моделей

### Модель с id и title

```typescript
// LoanData, EmploymentFormData, HiredEmploymentTypeData, IncomeVerificationData
value={options.find((option) => option.id === value)}
getOptionLabel={(option) => option.title}
getOptionKey={(option) => option.id}
onChange={(v) => {
    if (!v || typeof v === 'string') {
        onChange(null);
    } else {
        onChange(v.id);
    }
}}
```

### Модель с fiasId и region

```typescript
// RegionData
value={options.find((option) => option.fiasId === value)}
getOptionLabel={(option) => option.region}
getOptionKey={(option) => option.fiasId}
onChange={(v) => {
    if (!v || typeof v === 'string') {
        onChange(null);
    } else {
        onChange(v.fiasId);
    }
}}
```

### Модель с другими полями

Адаптируйте `getOptionLabel`, `getOptionKey` и `onChange` под структуру конкретной модели.

## Частые ошибки

❌ **Неправильно:** Добавление бизнес-логики в поле

```typescript
export const EmploymentForm = () => {
    const [data, setData] = useState([]);
    useEffect(() => {
        fetchData(); // ❌ Не делайте так!
    }, []);
    // ...
};
```

✅ **Правильно:** Поле только отображает данные

```typescript
export const EmploymentForm = ({value, onChange, options, loading}) => {
    return <Autocomplete /* ... */ />;
};
```

❌ **Неправильно:** Нет типизации

```typescript
export const EmploymentForm = ({value, onChange, options}) => {
    // ...
};
```

✅ **Правильно:** Используйте правильные базовые типы

```typescript
// Для Autocomplete со string значением (ID)
export const HiredEmploymentType = ({
    value,
    onChange,
    options
}: AutocompleteFieldProps<HiredEmploymentTypeData>) => {
    // ...
};

// Для Autocomplete с enum значением
export const EmploymentForm = ({
    value,
    onChange,
    options
}: AutocompleteFieldProps<EmploymentFormData, EmploymentFormTypes>) => {
    // ...
};

// Для простого Input - BaseFieldProps (по умолчанию string)
export const WorkPlace = ({value, onChange}: BaseFieldProps) => {
    // ...
};

// Для числового поля - BaseFieldProps<number>
export const LoanTerm = ({value, onChange}: BaseFieldProps<number> & {onBlur?: () => void}) => {
    // ...
};

// Для поля загрузки файлов - FileUploadFieldProps
export const CreditFiles = ({
    value,
    onChange,
    onDelete,
    acceptTypes,
    maxSizeMB,
    dropZoneText
}: FileUploadFieldProps) => {
    // ...
};
```

❌ **Неправильно:** Изменение существующих полей под конкретную задачу

```typescript
// Не изменяйте существующие поля!
// Создайте новое поле, если нужна другая логика
```

✅ **Правильно:** Используйте параметры для кастомизации

```typescript
<Field.EmploymentForm label="Кастомный label" className={customClass} />
```

❌ **Неправильно:** Импорт типов из неправильного места

```typescript
// ❌ Не импортируйте типы из других полей
import {BaseFieldProps} from '../Name/Name';
```

✅ **Правильно:** Импорт типов из types.ts

```typescript
// ✅ Всегда импортируйте типы из types.ts
import {BaseFieldProps} from '../types';
```

## Связанные файлы

- **Типы пропсов:** `/df-landing/src/components/FormFields/types.ts`
- **Объект Field:** `/df-landing/src/components/FormFields/Field.ts`
- **Общие стили:** `/df-landing/src/components/FormFields/FormFields.module.scss`
- **Модели данных:** `/df-landing/src/models/DadataModels.ts`, `/df-landing/src/models/index.ts`
- **Типы API:** `/df-landing/src/api/types/DadataTypes.ts`
- **UI компоненты:** `/df-landing/src/ui/` (Input, Autocomplete, Chip, FileUploader и др.)
- **Вспомогательные компоненты:** `/df-landing/src/components/shared/` (CheckList, InputWithSlider)

## Дополнительные рекомендации

1. **Модульность:** Каждое поле - независимый модуль в отдельной папке
2. **Консистентность:** Следуйте паттернам существующих полей
3. **Переиспользование:** Создавайте универсальные поля, которые можно использовать в разных формах
4. **Типизация:** Всегда используйте строгую типизацию TypeScript
    - Импортируйте базовые типы из `../types`
    - Для `AutocompleteFieldProps` указывайте второй дженерик `K` только если значение НЕ является простым `string` (ID)
    - Используйте enum-типы или кастомные типы для значений, если это требуется бизнес-логикой
5. **Документация:** Добавляйте комментарии для сложных полей
6. **Тестирование:** После добавления проверьте работу поля в реальной форме

## Часто используемые паттерны типизации

### Autocomplete с string ID (стандартный случай)

```typescript
AutocompleteFieldProps<LoanData>;
// value: string | null
// onChange: (value: string | null) => void
```

### Autocomplete с enum значением

```typescript
AutocompleteFieldProps<EmploymentFormData, EmploymentFormTypes>;
// value: EmploymentFormTypes | null
// onChange: (value: EmploymentFormTypes | null) => void
```

### Autocomplete с множественным выбором

```typescript
AutocompleteFieldProps<RegionData, string[]>;
// value: string[] | null
// onChange: (value: string[] | null) => void
```

### Input с числовым значением

```typescript
BaseFieldProps<number>;
// value: number | null
// onChange: (value: number | null) => void
```

### Поле загрузки файлов

```typescript
FileUploadFieldProps;
// value: File[]
// onChange: (value: File[]) => void
// onDelete?: (file: File) => void
// acceptTypes?: AcceptTypes[]
// maxSizeMB?: number
// dropZoneText?: string
```

### CheckList с типизированными опциями

```typescript
CheckListFieldProps<WorkTypesUnion> & {
    workTypes: WorkTypesUnion[];
};
// value: WorkTypesUnion[] | null
// onChange: (value: WorkTypesUnion[] | null) => void
```
